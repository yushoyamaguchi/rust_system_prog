# std::threadとの違い
タスクのブロックなどを行うときに、std::threadではsleepを使うが、tokioではsleepを使わずに、タスクをスケジューリングすることで、他のタスクに処理を譲る。
(例えば複数のTCP接続を受け付けるプログラムにおいて、threadを使う場合は、何もせず待つだけのOSスレッドを相手の数だけ用意する必要があるため、リソースの無駄遣いになる)
逆にシンプルな並列処理をしたいだけなら、async関数とかを使わずにstd::threadを使ってもできる。
<br>
IOバウンドな時は非同期、CPUバウンドな時はスレッドを使うというのが良い？

# async/await
async : asyncキーワードをつけることで、関数が非同期であると明示する。 
async関数はFuture型を返す
<br>
await : (async関数).await とすることで、その関数の終了を待つ(ステートマシンの終了)
async関数の中だけで使える

spawnを使って非同期的に実行した非同期関数(Future型を返している)の結果を取得したい場合は、awaitを使う必要がある。
<br>
ResultやOptionを返すasync関数の場合、await?を使うことで、エラー/Noneをそのまま伝播させて返すことができる。

# tokio
非同期I/O、タスクスケジューリング、タイマーなどを提供するランタイム

# スレッド
rustのスレッド・軽量タスクは、何も言わなければ全てdetachされる

# 余談:ブロッキング/ノンブロッキングIO
https://blog.takanabe.tokyo/2015/03/ノンブロッキングi/oと非同期i/oの違いを理解する/

# block_on
## 目的
 非同期タスクを同期的に実行し、結果を待つための範囲を作る。
 自分が実行するわけではなく、そのスレッドの流れをブロックし、block_on内で実行される非同期タスクの結果を待つ。
 block_on内での非同期タスクの実行は、普通に実行する(この場合並列処理はされない？) or spawnとかで別タスクとして実行する必要がある。
## 動作
 block_onは非同期タスクを実行し、その結果が返るまで現在のスレッドをブロックします。
## 使用シーン
 主に非同期コードと同期コードの境界で使われます。例えば、非同期関数の結果をメイン関数や他の同期関数から同期的に待ちたい場合など。
## 注意点
```#[tokio::main]```これをつけることで、async fn main() が同期的な fn main() へと変換されます。この変換後の fn main() 内で、ランタイムの初期化処理と、非同期処理の実行が行われます
```
#[tokio::main]
async fn main() {
    println!("hello");
}
```
上と下は同じ
```
fn main() {
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        println!("hello");
    })
}
```

## 備考
spawnで作って実行した非同期タスクを引数にとって、その結果を同期的に待つという使い方もできる。
awaitで待つのとの違いは、こちらはasync関数じゃないところで使うということ。

# spawn
新たなタスクやスレッドを生成し、その中で指定したコードを非同期に実行するための操作。
<br>
std::threadの場合はOSのスレッド、tokioの場合はコンテキストスイッチが容易い軽量タスクが生成される
<br>
joinと違い、新たなタスクとしてスケジュールされる

# join
pthreadと違って、待つだけでなく、Futureを引数として渡して、そのFutureを終わらせるという意味もある(tokioの場合だけ？)
(Futureをスレッドorタスクに割り当てることで)Futureを完了させ、スレッドorタスクが終了するのを待つ、という感じ？
<br>
複数の非同期タスクや非同期関数を同時に実行し、それらすべての完了を待ちたい場合に使用する。
async関数やasyncブロックの中でのみ使用可能。
<br>
spawnと違い、同じコンテキスト内で並行実行される。
そのため、joinで指定した複数の処理がすべて終わるまで、現在のタスクがブロックされてしまう。


# 引用
https://caddi.tech/archives/1997
## async関数は「あとでやっておきますよオブジェクト」を返すもの。

- 「あとでやっておきますよオブジェクト」は正しくはステートマシン(State Machine)という
- 厳密には「 あとでやっておく」＋「言われたら出来るところまで進めておく」。
- すなわち「まだ途中で今ここ」「もう終わった」などのステート（状態）を持つマシン(計算機)
- 残りの処理の内容も含めてステートマシンが持っているので、途中の状態のステートマシンをスレッド間で渡し合うことで、柔軟に並列処理できる（便利！）
- RustではFutureオブジェクトがステートマシンの実装の一例。かつてFutureはデファクトなクレートだったが、Rust1.39で標準ライブラリに入った。
    - Future::pollを呼ぶことが「出来るところまで進めるように言う」に相当する。

## ステートマシンとは別に「ステートマシン走らせる人」がいて初めて非同期処理が出来る。

- 「ステートマシン走らせる人」をランタイム(Runtime)と呼ぶ
    - Rust文脈だとFuture::pollをうまく呼ぶ人
- ランタイムはステートマシンの様子を見ながら適宜「出来るところまでやるように言う」。
- Runtimeの例：tokio
    - 他にも色々 https://qiita.com/benki/items/0792444cd6c2a162fb56
- block_on(非同期タスク)ってやればとりあえず実行できる、、、？

## 非同期関数を作るときは、awaitのタイミングを意識しないと非同期処理の恩恵が受けられない

- awaitを付けるとFutureが終わるまで待たせる
- awaitを付ける行為はステートマシンの「途中まで」の「途中」を増やすだけ。それだけでは並列処理にはならない。
    - 昔作ったfutureをあとでawaitすると並列化した気になるけれど、実はawaitのタイミングまでfutureの中身の処理は走らない。
- 並列化したかったらspawnして独立したタスクとして切り出すか、joinやselectなど「複数のFutureを渡してよしなに全部終わらせてくれるやつ」を使う必要がある。

## 注意点
ステートマシン(Future)とタスク・スレッドというのは別の概念！

# 注意点
スレッドのさらにその中に、ランタイムが独自に生成した(非同期)タスクが存在しているので注意。

# オマケ : unwrap
unwrap()は、ResultやOptionを返す関数の戻り値を取り出すときに使う。(エラーハンドリングは考慮しない)
