# async/await
async : asyncキーワードをつけることで、関数が非同期であると明示する。 
async関数はFuture型を返す
<br>
await : (async関数).await とすることで、その関数の終了を待つ(ステートマシンの終了)
async関数の中だけで使える

# tokio
非同期I/O、タスクスケジューリング、タイマーなどを提供するランタイム

# 余談:ブロッキング/ノンブロッキングIO
https://blog.takanabe.tokyo/2015/03/ノンブロッキングi/oと非同期i/oの違いを理解する/

# spawn
新たなタスクやスレッドを生成し、その中で指定したコードを非同期に実行するための操作。
<br>
std::threadの場合はOSのスレッド、tokioの場合はコンテキストスイッチが容易い軽量タスクが生成される
<br>
JoinHandle型が返される。
JoinHandle型の中には、joinメソッド(pthreadのjoinと同じく終了を待つ関数)が実装されている。

# join
pthreadと違って、待つだけでなく、Futureを引数として渡して、そのFutureを終わらせるという意味もある(tokioの場合だけ？)
(Futureをスレッドorタスクに割り当てることで)Futureを完了させ、スレッドorタスクが終了するのを待つ、という感じ？


# 引用
https://caddi.tech/archives/1997
## async関数は「あとでやっておきますよオブジェクト」を返すもの。

- 「あとでやっておきますよオブジェクト」は正しくはステートマシン(State Machine)という
- 厳密には「 あとでやっておく」＋「言われたら出来るところまで進めておく」。
- すなわち「まだ途中で今ここ」「もう終わった」などのステート（状態）を持つマシン(計算機)
- 残りの処理の内容も含めてステートマシンが持っているので、途中の状態のステートマシンをスレッド間で渡し合うことで、柔軟に並列処理できる（便利！）
- RustではFutureオブジェクトがステートマシンの実装の一例。かつてFutureはデファクトなクレートだったが、Rust1.39で標準ライブラリに入った。
    - Future::pollを呼ぶことが「出来るところまで進めるように言う」に相当する。

## ステートマシンとは別に「ステートマシン走らせる人」がいて初めて非同期処理が出来る。

- 「ステートマシン走らせる人」をランタイム(Runtime)と呼ぶ
    - Rust文脈だとFuture::pollをうまく呼ぶ人
- ランタイムはステートマシンの様子を見ながら適宜「出来るところまでやるように言う」。
- Runtimeの例：tokio
    - 他にも色々 https://qiita.com/benki/items/0792444cd6c2a162fb56
- block_on(非同期タスク)ってやればとりあえず実行できる、、、？

## 非同期関数を作るときは、awaitのタイミングを意識しないと非同期処理の恩恵が受けられない

- awaitを付けるとFutureが終わるまで待たせる
- awaitを付ける行為はステートマシンの「途中まで」の「途中」を増やすだけ。それだけでは並列処理にはならない。
    - 昔作ったfutureをあとでawaitすると並列化した気になるけれど、実はawaitのタイミングまでfutureの中身の処理は走らない。
- 並列化したかったらspawnして独立したタスクとして切り出すか、joinやselectなど「複数のFutureを渡してよしなに全部終わらせてくれるやつ」を使う必要がある。

## 注意点
ステートマシン(Future)とタスク・スレッドというのは別の概念！
